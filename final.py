import math
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats

xL = []
yL = []

for x in range(0,100):
    #y = 12 * (x**4) * math.sin(math.cos(x)) / (18 * (x ** 3) + 5 * (x ** 2) + (10 * x) - 30)
    y = 1.4 * (x**4) * math.sin(math.cos(x)) / (1.8 * (x ** 3) + 0.5 * (x ** 2) + (2 * x) - 3)    
    xL.append(x)
    yL.append(y)
    if round(y,2) == 1:
    	print(format("f = {0}".format(y)))

plt.plot(xL, yL)
plt.show()

# Для решения, я преобразовал все в пропорцию, где справа всегда 1, а слева ...
# Слева все остальное, с чем могут быть проблемы. Соответственно использую простой
# способ перебора, хочется надеяться что когда нибудь все это будет тождественно 1.
# Возможно, даже несколько раз. Логично предположить, что может быть немало других 
# способов, уже математических скорее, решить это уравнение ... 

# Первый частный случай, если нам хватит точности до двух знаков после запятой,
# Получается очень быстро на пятой итерации, то есть при x = 4 ... Можно пробовать
# искать далее, либо менять условия если вдруг точность не подходит ... Я использовал такой
# подход, скорее чтобы разобраться с jupyter, возможно вместо exel он будет более практичен
# или будет использоваться вместе с ним ... 

# Иных способов решать такие уравнения, как и проводить исследование их я не знаю ... 
# Так как уже с корнями возникают неопределенности, разрешение которых потребует
# очень много ресурсов ... График еще построил, чуть не забыл ... 
# Синус заполняющий пространство ... Волна какая-то как будто бы ... Не знакома мне такая.

